<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>前端面试题整理 | Mochicar の 博客</title><meta name="author" content="Mochicar"><meta name="copyright" content="Mochicar"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="文章目录 1. 函数柯里化 2. get和post的差别 @不熟 3. request payload 和 form data之间的区别 4. HTTP、HTTPs协议详细介绍 1. HTTP协议详细信息 2. HTTP协议的特点 3. HTTP工作流程 4. HTTP协议请求方式(共8种) 5.HTTP协议状态码 6.HTTPS   5.v8引擎的AST是什么 6.BFC 7.文档流 文档流(标">
<meta property="og:type" content="article">
<meta property="og:title" content="前端面试题整理">
<meta property="og:url" content="http://mochica.top/post/8fe9c4e1">
<meta property="og:site_name" content="Mochicar の 博客">
<meta property="og:description" content="文章目录 1. 函数柯里化 2. get和post的差别 @不熟 3. request payload 和 form data之间的区别 4. HTTP、HTTPs协议详细介绍 1. HTTP协议详细信息 2. HTTP协议的特点 3. HTTP工作流程 4. HTTP协议请求方式(共8种) 5.HTTP协议状态码 6.HTTPS   5.v8引擎的AST是什么 6.BFC 7.文档流 文档流(标">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://mochica.top/img/boy.png">
<meta property="article:published_time" content="2023-08-01T05:59:52.000Z">
<meta property="article:modified_time" content="2023-08-01T06:00:00.679Z">
<meta property="article:author" content="Mochicar">
<meta property="article:tag" content="blog 博客">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://mochica.top/img/boy.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://mochica.top/post/8fe9c4e1"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.19/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdnjs.cloudflare.com/ajax/libs/flickr-justified-gallery/2.1.2/fjGallery.min.js',
      css: 'https://cdnjs.cloudflare.com/ajax/libs/flickr-justified-gallery/2.1.2/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '前端面试题整理',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-08-01 14:00:00'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="https://npm.elemecdn.com/ethan4116-blog/lib/css/plane_v2.css"><link rel="stylesheet" href="/css/cat.css"><link rel="stylesheet" href="/css/rightMenu.css"><link rel="stylesheet" href="/css/custom.css"><div id="myscoll"></div><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/boy.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">12</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-amazon"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="Mochicar の 博客"><img class="site-icon" src="/img/boy.png"/><span class="site-name">Mochicar の 博客</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-amazon"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">前端面试题整理</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-08-01T05:59:52.000Z" title="发表于 2023-08-01 13:59:52">2023-08-01</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-08-01T06:00:00.679Z" title="更新于 2023-08-01 14:00:00">2023-08-01</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="前端面试题整理"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h3 id="文章目录"><a href="#文章目录" class="headerlink" title="文章目录"></a>文章目录</h3><ul>
<li><a href="#1-%E5%87%BD%E6%95%B0%E6%9F%AF%E9%87%8C%E5%8C%96">1. 函数柯里化</a></li>
<li><a href="#2-get%E5%92%8Cpost%E7%9A%84%E5%B7%AE%E5%88%AB">2. get和post的差别</a></li>
<li><a href="#%E4%B8%8D%E7%86%9F-3-request-payload-%E5%92%8C-form-data%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB">@不熟 3. request payload 和 form data之间的区别</a></li>
<li><a href="#4-httphttps%E5%8D%8F%E8%AE%AE%E8%AF%A6%E7%BB%86%E4%BB%8B%E7%BB%8D">4. HTTP、HTTPs协议详细介绍</a><ul>
<li><a href="#1-http%E5%8D%8F%E8%AE%AE%E8%AF%A6%E7%BB%86%E4%BF%A1%E6%81%AF">1. HTTP协议详细信息</a></li>
<li><a href="#2-http%E5%8D%8F%E8%AE%AE%E7%9A%84%E7%89%B9%E7%82%B9">2. HTTP协议的特点</a></li>
<li><a href="#3-http%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B">3. HTTP工作流程</a></li>
<li><a href="#4-http%E5%8D%8F%E8%AE%AE%E8%AF%B7%E6%B1%82%E6%96%B9%E5%BC%8F%E5%85%B18%E7%A7%8D">4. HTTP协议请求方式(共8种)</a></li>
<li><a href="#5http%E5%8D%8F%E8%AE%AE%E7%8A%B6%E6%80%81%E7%A0%81">5.HTTP协议状态码</a></li>
<li><a href="#6https">6.HTTPS</a></li>
</ul>
</li>
<li><a href="#5v8%E5%BC%95%E6%93%8E%E7%9A%84ast%E6%98%AF%E4%BB%80%E4%B9%88">5.v8引擎的AST是什么</a></li>
<li><a href="#6bfc">6.BFC</a></li>
<li><a href="#7%E6%96%87%E6%A1%A3%E6%B5%81">7.文档流</a><ul>
<li><a href="#%E6%96%87%E6%A1%A3%E6%B5%81%E6%A0%87%E5%87%86%E6%B5%81%E6%99%AE%E9%80%9A%E6%B5%81">文档流(标准流、普通流)</a></li>
<li><a href="#%E6%B5%AE%E5%8A%A8%E6%B5%81">浮动流</a></li>
<li><a href="#%E5%AE%9A%E4%BD%8D%E6%B5%81">定位流</a></li>
</ul>
</li>
<li><a href="#8%E5%B8%83%E5%B1%80%E6%96%B9%E6%A1%88">8.布局方案</a></li>
<li><a href="#9%E6%B5%8F%E8%A7%88%E5%99%A8%E4%BB%8E%E5%8F%91%E5%87%BA%E8%AF%B7%E6%B1%82%E5%88%B0%E6%8E%A5%E5%8F%97%E5%93%8D%E5%BA%94%E4%B8%AD%E9%97%B4%E8%BF%87%E7%A8%8B">9.浏览器从发出请求到接受响应,中间过程</a></li>
<li><a href="#10%E5%89%8D%E7%AB%AF%E5%AD%98%E5%82%A8">10.前端存储</a><ul>
<li><a href="#%E4%BC%98%E5%8A%BF">优势</a></li>
<li><a href="#%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F">存储方式</a><ul>
<li><a href="#%E5%AD%98%E5%82%A8%E7%B1%BB">存储类</a><ul>
<li><a href="#12-web-storagelocalstoragesessionstorage">1、2. Web Storage(localStorage、sessionStorage)</a></li>
<li><a href="#3cookie">3.cookie</a></li>
<li><a href="#4-indexdb">4. IndexDB</a></li>
<li><a href="#5-web-sql">5. Web SQL</a></li>
</ul>
</li>
<li><a href="#%E7%BC%93%E5%AD%98%E7%B1%BB">缓存类</a><ul>
<li><a href="#1-cache-storage">1. Cache Storage</a></li>
<li><a href="#2-application-cache">2. Application Cache</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#11vite%E5%92%8Cwebpack%E7%9A%84%E5%8C%BA%E5%88%AB">11.vite和webpack的区别</a></li>
<li><a href="#12%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86%E5%AD%98%E5%82%A8--localstorage">12.状态管理存储 , localstorage</a></li>
<li><a href="#%E4%B8%8D%E7%86%9F-13h5%E6%96%B0%E7%89%B9%E6%96%B0web-workerwebsocket">@不熟 13.H5新特新:Web Worker、WebSocket</a></li>
<li><a href="#14vue-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%9A%84%E7%90%86%E8%A7%A3">14.Vue 生命周期的理解</a><ul>
<li><a href="#vue2">vue2</a></li>
<li><a href="#vue3%E9%80%89%E9%A1%B9%E5%BC%8F">vue3选项式</a></li>
<li><a href="#vue3%E7%BB%84%E5%90%88%E5%BC%8F">vue3组合式</a></li>
</ul>
</li>
<li><a href="#15%E8%B0%88%E4%B8%80%E8%B0%88%E5%AF%B9-mvvm-%E7%9A%84%E7%90%86%E8%A7%A3">15.谈一谈对 MVVM 的理解？</a></li>
<li><a href="#16vue-%E5%AE%9E%E7%8E%B0%E5%8F%8C%E5%90%91%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A%E7%9A%84%E5%8E%9F%E7%90%86">16.Vue 实现双向数据绑定的原理？</a><ul>
<li><a href="#vue2-1">vue2</a></li>
<li><a href="#vue3">vue3</a></li>
</ul>
</li>
<li><a href="#17vue2x-%E4%B8%AD%E5%A6%82%E4%BD%95%E6%A3%80%E6%B5%8B%E6%95%B0%E7%BB%84%E7%9A%84%E5%8F%98%E5%8C%96">17.Vue2.x 中如何检测数组的变化？</a></li>
<li><a href="#%E4%B8%8D%E7%86%9F-18vue2x-%E5%92%8C-vuex3x-%E6%B8%B2%E6%9F%93%E5%99%A8%E7%9A%84-diff-%E7%AE%97%E6%B3%95%E5%88%86%E5%88%AB%E8%AF%B4%E4%B8%80%E4%B8%8B">不熟@ 18.vue2.x 和 vuex3.x 渲染器的 diff 算法分别说一下？</a><ul>
<li><a href="#vue2-2">vue2</a></li>
<li><a href="#vue3-1">vue3</a></li>
</ul>
</li>
<li><a href="#19vue-%E7%9A%84%E8%B7%AF%E7%94%B1%E5%AE%9E%E7%8E%B0">19.Vue 的路由实现</a><ul>
<li><a href="#hashhistory%E8%B7%AF%E7%94%B1">HashHistory路由</a></li>
<li><a href="#history%E8%B7%AF%E7%94%B1">history路由</a></li>
<li><a href="#%E4%B8%A4%E7%A7%8D%E8%B7%AF%E7%94%B1%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%8C%BA%E5%88%AB">两种路由模式的区别</a></li>
<li><a href="#%E4%B8%A4%E7%A7%8D%E8%B7%AF%E7%94%B1%E6%A8%A1%E5%BC%8F%E8%B7%B3%E8%BD%ACapi%E7%9A%84%E5%8C%BA%E5%88%AB">两种路由模式跳转API的区别</a></li>
</ul>
</li>
<li><a href="#20vuex%E5%92%8Cpina%E7%9A%84%E5%8C%BA%E5%88%AB">20.vuex和pina的区别?</a><ul>
<li><a href="#vuex">vuex</a></li>
<li><a href="#pinia">pinia</a></li>
<li><a href="#vuex%E4%B8%8Epinia%E7%9A%84%E5%8C%BA%E5%88%AB">vuex与pinia的区别</a></li>
</ul>
</li>
<li><a href="#21nexttick-%E7%9A%84%E4%BD%9C%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88%E4%BB%96%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88">21.<code>nextTick</code> 的作用是什么？他的实现原理是什么？</a></li>
<li><a href="#22%E7%83%AD%E6%9B%B4%E6%96%B0">22.热更新</a></li>
<li><a href="#23%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%B8%B2%E6%9F%93ssr">23.服务端渲染(SSR)</a><ul>
<li><a href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%B8%B2%E6%9F%93">什么是服务端渲染</a></li>
<li><a href="#%E4%BC%98%E7%82%B9">优点</a></li>
<li><a href="#%E7%BC%BA%E7%82%B9">缺点</a></li>
<li><a href="#%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E6%B8%B2%E6%9F%93%E7%9A%84%E6%96%B9%E5%BC%8F">服务器端渲染的方式</a></li>
<li><a href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF">应用场景</a></li>
</ul>
</li>
<li><a href="#24react-hooks">24.react-hooks</a><ul>
<li><a href="#1-usestate">1. useState()</a></li>
<li><a href="#2-usereducer">2. useReducer()</a></li>
<li><a href="#3-usecontext">3. useContext()</a></li>
<li><a href="#4-useeffect">4. useEffect()</a></li>
<li><a href="#5-usememo">5. useMemo()</a></li>
<li><a href="#6-usecallback">6. useCallBack()</a></li>
<li><a href="#7-useref">7. useRef()</a></li>
<li><a href="#8-%E8%87%AA%E5%AE%9A%E4%B9%89hooks">8. 自定义hooks</a></li>
<li><a href="#9-react%E8%B7%AF%E7%94%B1hooks">9. React路由Hooks</a></li>
</ul>
</li>
<li><a href="#25redux">25.redux</a></li>
<li><a href="#26callapplybind%E7%9A%84%E4%BD%9C%E7%94%A8%E5%92%8C%E5%8C%BA%E5%88%AB">26.call、apply、bind的作用和区别</a><ul>
<li><a href="#%E5%85%B1%E5%90%8C%E7%82%B9">共同点</a></li>
<li><a href="#%E4%B8%8D%E5%90%8C%E7%82%B9">不同点</a></li>
<li><a href="#call%E6%96%B9%E6%B3%95">call()方法</a></li>
<li><a href="#apply%E6%96%B9%E6%B3%95">apply()方法</a></li>
<li><a href="#bind%E6%96%B9%E6%B3%95">bind()方法</a></li>
</ul>
</li>
<li><a href="#27this%E6%8C%87%E5%90%91">27.this指向</a><ul>
<li><a href="#%E6%A6%82%E5%BF%B5">概念</a></li>
<li><a href="#this%E7%9A%84%E6%8C%87%E5%90%91">this的指向</a></li>
</ul>
</li>
<li><a href="#28%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6">28.垃圾回收机制</a><ul>
<li><a href="#%E6%A0%87%E8%AE%B0%E6%B8%85%E9%99%A4%E6%B3%95">标记清除法</a></li>
</ul>
</li>
<li><a href="#29eventloop%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF">29.EventLoop(事件循环)</a></li>
<li><a href="#30%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E5%92%8C%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F">30.内存溢出和内存泄漏</a><ul>
<li><a href="#%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2">内存泄露</a></li>
<li><a href="#%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA">内存溢出</a></li>
</ul>
</li>
</ul>
<h1 id="1-函数柯里化"><a href="#1-函数柯里化" class="headerlink" title="1. 函数柯里化"></a>1. 函数柯里化</h1><ul>
<li>使用：固定部分参数，返回接收剩余参数的函数，</li>
<li>目的：建一个针对性更强的函数</li>
<li>核心思想：把多参数传入的函数，拆成一个个的单参数的函数，内部再返回调用下一个单（或部分）参数的函数，依次处理剩余参数</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 柯里化前</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">log</span> = (<span class="params">date, project, message</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;date&#125;</span> <span class="subst">$&#123;project&#125;</span> <span class="subst">$&#123;message&#125;</span>`</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出2022-07-29 xxx后台管理系统 mm接口异常</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">log</span>(<span class="string">&#x27;2022-07-29&#x27;</span>, <span class="string">&#x27;xxx后台管理系统&#x27;</span>, <span class="string">&#x27;mm接口异常&#x27;</span>)) </span><br><span class="line"></span><br><span class="line"><span class="comment">//柯里化后</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">log</span> = (<span class="params">date</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">projectName</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function">(<span class="params">message</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;date&#125;</span> <span class="subst">$&#123;projectName&#125;</span> <span class="subst">$&#123;message&#125;</span>`</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//那个参数固定，则传入同一个参数，只改要变的参数</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">log</span>(<span class="string">&#x27;2022-07-29&#x27;</span>)(<span class="string">&#x27;A项目&#x27;</span>)(<span class="string">&#x27;接口报错&#x27;</span>)); </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="2-get和post的差别"><a href="#2-get和post的差别" class="headerlink" title="2. get和post的差别"></a>2. get和post的差别</h1><ul>
<li>参数：get通过拼接url进行参数传递，参数可见；post通过请求头传递参数，参数不可见</li>
<li>数据携带量：get请求携带的数据不超过2~4k，(浏览器不同，携带量不同，但相差不大)；post请求携带量根据配置文件设定，无上限</li>
<li>后退页面的反应： 页面后退，get请求无影响，post请求需要重新提交请求</li>
<li>缓存性：get请求可以缓存，post请求不可缓存</li>
<li>传输速度：get比post更快。(get产生一个TCP数据包；post产生两个TCP数据包)</li>
<li>安全性：原则上post更安全，因为post的数据在url上不可见</li>
</ul>
<h1 id="不熟-3-request-payload-和-form-data之间的区别"><a href="#不熟-3-request-payload-和-form-data之间的区别" class="headerlink" title="@不熟 3. request payload 和 form data之间的区别"></a>@不熟 3. request payload 和 form data之间的区别</h1><ul>
<li>FormData和Payload是浏览器传输给接口的两种格式，这两种方式浏览器是通过Content-Type来进行区分的。</li>
<li>Content-Type是指 HTTP 请求发送信息至服务器时的内容编码类型</li>
<li>RequestPayload是(HTTP请求体模式)，FormData是(表单请求体模式)</li>
</ul>
<h1 id="4-HTTP、HTTPs协议详细介绍"><a href="#4-HTTP、HTTPs协议详细介绍" class="headerlink" title="4. HTTP、HTTPs协议详细介绍"></a>4. HTTP、HTTPs协议详细介绍</h1><h3 id="1-HTTP协议详细信息"><a href="#1-HTTP协议详细信息" class="headerlink" title="1. HTTP协议详细信息"></a>1. HTTP协议详细信息</h3><ul>
<li>HTTP(超文本传输协议)，是一种详细规定了浏览器和万维网服务器之间相互通信的规则，通过因特网传送万维网文档的数据传输协议</li>
<li>HTTP是基于TCP&#x2F;IP的应用层协议</li>
<li>HTTP不仅能应用于网页浏览，只要通信双方都遵守HTTP协议，都能使用HTTP协议</li>
</ul>
<h3 id="2-HTTP协议的特点"><a href="#2-HTTP协议的特点" class="headerlink" title="2. HTTP协议的特点"></a>2. HTTP协议的特点</h3><ul>
<li>简单快速：只需传送请求方法和路径</li>
<li>灵活：允许传输任意类型数据对象</li>
<li>无状态：指协议对于事件处理没有记忆能力，缺少状态意味着如果后续处理需要前面的信息,则它必须重传,这样可能导致每次连接传送的数据量增大。</li>
<li>支持B&#x2F;S、C&#x2F;S模式</li>
</ul>
<h3 id="3-HTTP工作流程"><a href="#3-HTTP工作流程" class="headerlink" title="3. HTTP工作流程"></a>3. HTTP工作流程</h3><ul>
<li>浏览器与服务器建立连接</li>
<li>浏览器向服务器发送请求</li>
<li>服务器接收请求，</li>
<li>向浏览器返回响应</li>
<li>浏览器接收到响应，渲染页面</li>
<li>断开与服务器的连接</li>
</ul>
<h3 id="4-HTTP协议请求方式-共8种"><a href="#4-HTTP协议请求方式-共8种" class="headerlink" title="4. HTTP协议请求方式(共8种)"></a>4. HTTP协议请求方式(共8种)</h3><blockquote>
<p>HTTP 1.0 定义了三种(get、post、head)</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">get:获取,一般用于查询数据,在处理敏感数据时不用，或者参数做加密处理。请求参数拼接在url里</span><br><span class="line"></span><br><span class="line">post:一般用于修改数据,数据发送到服务器以创建或更新资源，侧重于更新数据。请求参数在请求body中</span><br><span class="line"></span><br><span class="line">head:head方法与get方法相同，但没有响应体，仅传输状态行和标题部分。这对于恢复相应头部编写的元数据非常有用，而无需传输整个内容。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>HTTP 1.1 新增了6种(put、delete、pacth、options、trace、connect)</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">put:一般用于新增数据,数据发送到服务器以创建或更新资源，侧重于创建数据</span><br><span class="line"></span><br><span class="line">delete:一般用于删除数据,用来删除指定的资源，它会删除URI给出的目标资源的所有当前内容</span><br><span class="line"></span><br><span class="line">pacth:用于资源的部分内容的更新；会在资源不存在时去创建它(有则修改，无则添加)</span><br><span class="line"></span><br><span class="line">options:用来描述了目标资源的通信选项，返回服务器针对特定资源所支持的HTTP请求方法，也可以利用向web服务器发送`*`的请求来测试服务器的功能性</span><br><span class="line"></span><br><span class="line">trace:用于沿着目标资源的路径执行消息环回测试；它回应收到的请求，以便客户可以看到中间服务器进行了哪些（假设任何）进度或增量。</span><br><span class="line"></span><br><span class="line">connect:用来建立到给定URI标识的服务器的隧道；它通过简单的TCP / IP隧道更改请求连接，通常是使用解码的HTTP代理来进行SSL编码的通信（HTTPS）</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="5-HTTP协议状态码"><a href="#5-HTTP协议状态码" class="headerlink" title="5.HTTP协议状态码"></a>5.HTTP协议状态码</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">100~199: 提供信息。</span><br><span class="line"></span><br><span class="line">200~299: 请求被成功提交。</span><br><span class="line"></span><br><span class="line">300~399: 客户端被重定向到其他资源。</span><br><span class="line"></span><br><span class="line">400~499: 请求包含某种错误。</span><br><span class="line"></span><br><span class="line">500~599: 服务器执行请求时遇到错误。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="6-HTTPS"><a href="#6-HTTPS" class="headerlink" title="6.HTTPS"></a>6.HTTPS</h3><ul>
<li>与http的区别：安全性比http高，是HTTP 的安全版</li>
<li>主要作用：建立一个信息安全通道，来确保数据的传输，确保网站的真实性</li>
<li>优点：确保数据发送到正确的客户端和服务器，确保数据的完整性，大幅度增加了中间人攻击的成本</li>
<li>缺点：增大了与服务器握手时间(大约增加了50%)，SSL证书需要收费</li>
</ul>
<h1 id="5-v8引擎的AST是什么"><a href="#5-v8引擎的AST是什么" class="headerlink" title="5.v8引擎的AST是什么"></a>5.v8引擎的AST是什么</h1><ul>
<li>V8引擎是使用AST(抽象语法树)来解析和转换js代码的</li>
<li>AST是解析和转换JavaScript代码的树状结构表示，它提供了一种便捷的方式来分析、修改和转换代码。</li>
</ul>
<h1 id="6-BFC"><a href="#6-BFC" class="headerlink" title="6.BFC"></a>6.BFC</h1><ul>
<li>BFC是块级格式化上下文，可以把BFC看成一个容器，容器内的元素不会影响到外部元素</li>
<li>BFC的特性</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. BFC是块级元素，在垂直方向上依次排列</span><br><span class="line">2. BFC是独立容器，内部元素不会影响到外部元素</span><br><span class="line">3. 同一个BFC里面的两个盒子，外边距会发生重叠，并取最大外边距</span><br><span class="line">4. 计算BFC高度时，浮动元素也要参与计算</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>创建BFC</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1. overflow:hidden      隐藏的内容</span><br><span class="line">2. display:flex         转变为弹性盒子，变现为块级元素</span><br><span class="line">3. position:abssolute   绝对定位</span><br><span class="line">4. position:fixed       固定定位</span><br><span class="line">5. display:inline-flex  转变为弹性盒子，变现为行内块元素</span><br><span class="line">6. display:inline-block 转变为行内块元素</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>BFC的作用：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. 解决父元素未设置高度，子元素浮动造成父元素高度塌陷的问题</span><br><span class="line">2. 解决子元素外边距错误的加到父元素上的问题</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="7-文档流"><a href="#7-文档流" class="headerlink" title="7.文档流"></a>7.文档流</h1><p>CSS 有三种基本的定位机制：普通流、浮动流、定位流。</p>
<h3 id="文档流-标准流、普通流"><a href="#文档流-标准流、普通流" class="headerlink" title="文档流(标准流、普通流)"></a>文档流(标准流、普通流)</h3><ul>
<li>html的默认排版方式</li>
<li>特点：块级元素上下排列，行内块元素、行内元素左右排列</li>
</ul>
<h3 id="浮动流"><a href="#浮动流" class="headerlink" title="浮动流"></a>浮动流</h3><ul>
<li>脱离标准流的排版方式，使用float：none&#x2F;left&#x2F;right实现</li>
<li>特点：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1. 浮动后的元素只有居左、居右、无三种属性，</span><br><span class="line">2. 浮动后的元素可以设置宽高</span><br><span class="line">3. 元素只在父元素宽高范围内浮动</span><br><span class="line">4. 浮动后的元素不可使用margin：0 auto;</span><br><span class="line">5. 元素浮动后，后面的同级元素会占据他原本的位置</span><br><span class="line">6. 如果两个浮动的元素的宽之和小于父元素宽，左右排列</span><br><span class="line">7. 如果两个浮动的元素的宽之和大于父元素宽，上下排列</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="定位流"><a href="#定位流" class="headerlink" title="定位流"></a>定位流</h3><ul>
<li>定位分为相对定位、绝对定位、固定定位、静态定位(文档流默认定位)</li>
<li>相对定位不脱离文档流，绝对定位、固定定位会脱离文档流</li>
<li>z-index属性是专门控制定位流元素的覆盖关系</li>
</ul>
<h1 id="8-布局方案"><a href="#8-布局方案" class="headerlink" title="8.布局方案"></a>8.布局方案</h1><ol>
<li>居中布局(水平居中、垂直居中、水平垂直居中)</li>
<li>双飞翼布局(侧边两栏宽度固定，中间栏宽度自适应)</li>
<li>圣杯布局(侧边两栏宽度固定，中间栏宽度自适应)</li>
<li>栅格布局</li>
</ol>
<h1 id="9-浏览器从发出请求到接受响应-中间过程"><a href="#9-浏览器从发出请求到接受响应-中间过程" class="headerlink" title="9.浏览器从发出请求到接受响应,中间过程"></a>9.浏览器从发出请求到接受响应,中间过程</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">1. 用户输入url，生成http请求</span><br><span class="line"></span><br><span class="line">2. 解析域名，得到IP地址。(根据url域名从本地hosts文件查找是否有映射IP，如果查找不到，则将域名发送给电脑所配置的DNS进行域名解析，得到IP地址)</span><br><span class="line"></span><br><span class="line">3. 建立TCP连接(三次握手)</span><br><span class="line"></span><br><span class="line">4. 向服务器发送HTTP请求</span><br><span class="line"></span><br><span class="line">5. 服务器收到请求</span><br><span class="line"></span><br><span class="line">6. servlet处理请求</span><br><span class="line"></span><br><span class="line">7. 将响应结果封装成 HTTP 响应的格式，发送给浏览器，关闭TCP连接，请求响应完成</span><br><span class="line"></span><br><span class="line">8. 浏览器收到响应数据，解析并渲染响应页面</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="10-前端存储"><a href="#10-前端存储" class="headerlink" title="10.前端存储"></a>10.前端存储</h1><h3 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h3><ol>
<li>方便网页加载，避免了在发送请求收到响应前的空白期</li>
<li>减少向服务器的请求次数，加快渲染速度</li>
<li>在网络不佳或无网络时，也可以离线浏览网页</li>
</ol>
<h3 id="存储方式"><a href="#存储方式" class="headerlink" title="存储方式"></a>存储方式</h3><p>分为存储类(cookie、localStroage、sessionStroage)、缓存类(Cache Storage、Application Cache)</p>
<h4 id="存储类"><a href="#存储类" class="headerlink" title="存储类"></a>存储类</h4><h5 id="1、2-Web-Storage-localStorage、sessionStorage"><a href="#1、2-Web-Storage-localStorage、sessionStorage" class="headerlink" title="1、2. Web Storage(localStorage、sessionStorage)"></a>1、2. Web Storage(localStorage、sessionStorage)</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">  <span class="title class_">HTML5</span>提出的存储方式，容量5M</span><br><span class="line"></span><br><span class="line">  优点：</span><br><span class="line">    <span class="number">1.</span> 克服了cookie的限制，同时存储一些要严格控制在客户端，不需要发送给服务器的数据</span><br><span class="line">    <span class="number">2.</span> 提供了除cookie之外的存储会话途径</span><br><span class="line">    <span class="number">3.</span> 存储容量大，跨会话存储数据</span><br><span class="line"></span><br><span class="line"><span class="string">``</span><span class="string">``</span><span class="string">``</span>js</span><br><span class="line">  <span class="variable language_">localStorage</span>：</span><br><span class="line">    <span class="number">1.</span> 永久存储，除非自动删除</span><br><span class="line">    <span class="number">2.</span> 保存在客户端，不与服务器进行交互通信</span><br><span class="line">    <span class="number">3.</span> 只能存储字符串类型，复杂数据类型会转化为json字符串保存</span><br><span class="line">    <span class="number">4.</span> 应用场景：适合长期保存在本地的数据</span><br><span class="line">    <span class="number">5.</span> 操作<span class="variable language_">localStorage</span></span><br><span class="line">      <span class="comment">//设置localStorage,有则修改，无则添加</span></span><br><span class="line">      <span class="comment">//将键值对存储在localStorage中</span></span><br><span class="line">      <span class="variable language_">localStorage</span>.<span class="title function_">setItem</span>(<span class="string">&quot;key&quot;</span>, <span class="string">&quot;value&quot;</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 获取localStorage</span></span><br><span class="line">      <span class="keyword">var</span> value = <span class="variable language_">localStorage</span>.<span class="title function_">getItem</span>(<span class="string">&quot;key&quot;</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">//删除localStorage</span></span><br><span class="line">      <span class="variable language_">localStorage</span>.<span class="title function_">removeItem</span>(<span class="string">&quot;key&quot;</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">//清空localStorage</span></span><br><span class="line">      <span class="variable language_">localStorage</span>.<span class="title function_">clear</span>();</span><br><span class="line"></span><br><span class="line"><span class="string">``</span><span class="string">``</span><span class="string">``</span>js</span><br><span class="line">  <span class="variable language_">sessionStorage</span>：</span><br><span class="line">    <span class="number">1.</span> 当前会话下有效，关闭浏览器，数据清除</span><br><span class="line">    <span class="number">2.</span> 保存在客户端，不与服务器进行交互通信</span><br><span class="line">    <span class="number">3.</span> 只能存储字符串类型，复杂数据类型会转化为json字符串保存</span><br><span class="line">    <span class="number">4.</span> 应用场景：敏感账号、一次性登录</span><br><span class="line">    <span class="number">5.</span> 操作<span class="variable language_">sessionStorage</span></span><br><span class="line">      <span class="comment">//设置localStorage,有则修改，无则添加</span></span><br><span class="line">      <span class="comment">//将键值对存储在localStorage中</span></span><br><span class="line">      <span class="variable language_">sessionStorage</span>.<span class="title function_">setItem</span>(<span class="string">&quot;key&quot;</span>, <span class="string">&quot;value&quot;</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 获取localStorage</span></span><br><span class="line">      <span class="keyword">var</span> value = <span class="variable language_">sessionStorage</span>.<span class="title function_">getItem</span>(<span class="string">&quot;key&quot;</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">//删除localStorage</span></span><br><span class="line">      <span class="variable language_">sessionStorage</span>.<span class="title function_">removeItem</span>(<span class="string">&quot;key&quot;</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">//清空localStorage</span></span><br><span class="line">      <span class="variable language_">sessionStorage</span>.<span class="title function_">clear</span>();</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="3-cookie"><a href="#3-cookie" class="headerlink" title="3.cookie"></a>3.cookie</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">  基于<span class="variable constant_">HTTP</span>协议的存储方式，浏览器普遍支持，容量4k</span><br><span class="line">  限制性：需要设置过期时间，过期自动清除，如果不设置，浏览器关闭就清除</span><br><span class="line">  优点：</span><br><span class="line">    <span class="number">1.</span> 可以控制过期时间，有一定的安全保障</span><br><span class="line">    <span class="number">2.</span> 可进行扩展，可跨域共享</span><br><span class="line">    <span class="number">3.</span> 通过加密与安全传输技术(<span class="variable constant_">SSL</span>)，可降低cookie被破解的风险</span><br><span class="line">    <span class="number">4.</span> 有较高的兼容性</span><br><span class="line">  缺点：</span><br><span class="line">    <span class="number">1.</span> 有数量和长度限制，每个cookie长度不能超过4kb，超过部分会被截掉</span><br><span class="line">    <span class="number">2.</span> 请求头上的数据容易被拦截攻击</span><br><span class="line"></span><br><span class="line"><span class="string">``</span><span class="string">``</span><span class="string">``</span>js</span><br><span class="line">  <span class="comment">//操作cookie</span></span><br><span class="line">    <span class="comment">//获取cookie：</span></span><br><span class="line">      <span class="comment">//获取所有cookie</span></span><br><span class="line">        <span class="keyword">var</span> cookies = <span class="variable language_">document</span>.<span class="property">cookie</span>;</span><br><span class="line">        <span class="comment">//返回的是一个字符串，形如&quot;cookie1=value1; cookie2=value2&quot;</span></span><br><span class="line">        <span class="comment">//使用splice(;)方法将字符串截并存储在数组中，方便提取数据</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//修改cookie：有则修改，无则添加</span></span><br><span class="line">    <span class="variable language_">document</span>.<span class="property">cookie</span> = <span class="string">&quot;name=value; expires=expiration_date; path=path; domain=domain; secure&quot;</span>;</span><br><span class="line">    <span class="comment">//name是Cookie的名称，value是Cookie的值。</span></span><br><span class="line">    <span class="comment">//expires是失效日期，格式为&quot;Mon, 28 Jun 2023 13:24:25 GMT&quot;。</span></span><br><span class="line">    <span class="comment">//path是可访问该Cookie的路径，默认是当前文件路径。</span></span><br><span class="line">    <span class="comment">//domain是可访问Cookie的域名，默认是当前域名。</span></span><br><span class="line">    <span class="comment">//secure指定Cookie只在使用HTTPS连接的情况下才发送。</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 删除cookie：</span></span><br><span class="line">    <span class="variable language_">document</span>.<span class="property">cookie</span>=<span class="string">&quot;要删除的键名=随便; expires=一个过去时间的GMT格式&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">``</span><span class="string">``</span><span class="string">``</span>js</span><br><span class="line">  <span class="variable language_">sessionStorage</span>、<span class="variable language_">localStorage</span>与cookie的区别</span><br><span class="line"></span><br><span class="line">  <span class="number">1.</span> 存储空间更大</span><br><span class="line"></span><br><span class="line">  <span class="number">2.</span> 节省网络流量</span><br><span class="line"></span><br><span class="line">  <span class="number">3.</span> 安全性更高，不用担心被截取</span><br><span class="line"></span><br><span class="line">  <span class="number">4.</span> 三者都是只能储存字符串，如果用<span class="title class_">WebStorage</span>(<span class="variable language_">sessionStorage</span>、<span class="variable language_">localStorage</span>)存储对象，会出现 [<span class="title class_">Object</span> <span class="title class_">Object</span>], 可以用 <span class="title class_">JSON</span>.<span class="property">stringify</span> 与 <span class="title class_">JSON</span>.<span class="property">parse</span>方法来解决这个问题。</span><br><span class="line"></span><br><span class="line">  <span class="number">5.</span> <span class="variable language_">sessionStorage</span>、<span class="variable language_">localStorage</span>以(key,value)的形式存储数据，cookie以键<span class="number">1</span>=值<span class="number">1</span>的形式存储数据</span><br><span class="line"></span><br><span class="line">  <span class="number">6.</span> <span class="variable language_">sessionStorage</span>、<span class="variable language_">localStorage</span>是作为<span class="variable language_">window</span>对象的属性存在，可以直接通过<span class="variable language_">window</span>.<span class="property">sessionstorage</span>、<span class="variable language_">window</span>.<span class="property">sessionstorage</span>来访问</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="4-IndexDB"><a href="#4-IndexDB" class="headerlink" title="4. IndexDB"></a>4. IndexDB</h5><h5 id="5-Web-SQL"><a href="#5-Web-SQL" class="headerlink" title="5. Web SQL"></a>5. Web SQL</h5><h4 id="缓存类"><a href="#缓存类" class="headerlink" title="缓存类"></a>缓存类</h4><h5 id="1-Cache-Storage"><a href="#1-Cache-Storage" class="headerlink" title="1. Cache Storage"></a>1. Cache Storage</h5><h5 id="2-Application-Cache"><a href="#2-Application-Cache" class="headerlink" title="2. Application Cache"></a>2. Application Cache</h5><h1 id="11-vite和webpack的区别"><a href="#11-vite和webpack的区别" class="headerlink" title="11.vite和webpack的区别"></a>11.vite和webpack的区别</h1><ul>
<li>Vite和Webpack都是现代化的前端构建工具，用于打包、编译、压缩和优化前端代码。</li>
<li>主要目的是将多个源文件（例如JavaScript，CSS和HTML文件）打包成更少的文件，以便在浏览器中加载更快，同时提供许多其他功能。</li>
<li>相同点</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 都可以处理各种静态资源，例如<span class="variable constant_">HTML</span>、<span class="variable constant_">CSS</span>、<span class="title class_">JavaScript</span>、图片和字体等</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> 都支持模块化开发，可以使用<span class="variable constant_">ES</span> <span class="title class_">Modules</span>、<span class="title class_">CommonJS</span>、<span class="variable constant_">AMD</span>等模块规范</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span> 都支持开发模式和生产模式，可以对代码进行压缩、混淆和优化等处理</span><br><span class="line"></span><br><span class="line"><span class="number">4.</span> 都支持插件机制，可以扩展和定制构建流程</span><br><span class="line"></span><br><span class="line"><span class="number">5.</span> 都可以处理热模块替换(<span class="variable constant_">HMR</span>)，在开发过程中快速更新修改的代码</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>不同点</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 构建方式不同</span><br><span class="line">  <span class="title class_">Webpack</span>采用静态依赖关系，需要在配置文件中声明入口文件和输出文件，并通过loader和plugin进行配置。<span class="title class_">Webpack</span>的构建方式比较复杂</span><br><span class="line"></span><br><span class="line">  <span class="title class_">Vite</span>采用动态导入方式，通过本地服务器实现快速构建和启动。<span class="title class_">Vite</span>的构建方式比较简单，无需配置多个入口文件和输出文件，同时可以自动识别模块依赖关系</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> 速度不同</span><br><span class="line">  <span class="title class_">Webpack</span>在处理大型项目时，构建速度可能会变慢。这是因为<span class="title class_">Webpack</span>在进行打包时，需要处理所有的模块，包括未使用的模块。这使得<span class="title class_">Webpack</span>的构建速度变慢</span><br><span class="line"></span><br><span class="line">  <span class="title class_">Vite</span>采用了按需编译方式，只会编译当前页面的相关模块，而不会处理未使用的模块。这使得<span class="title class_">Vite</span>的构建速度更快，可以快速启动项目和进行热更新</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span> 适用范围不同</span><br><span class="line">  <span class="title class_">Webpack</span>适用于大型复杂的<span class="title class_">Web</span>应用程序，可以处理各种类型的静态资源，并提供了强大的插件机制，可以满足各种复杂的构建需求</span><br><span class="line"></span><br><span class="line">  <span class="title class_">Vite</span>适用于中小型<span class="title class_">Web</span>应用程序，以及需要快速启动和热更新的开发场景。<span class="title class_">Vite</span>提供了快速构建和启动的能力，可以让开发者更加专注于业务逻辑的开发</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>总结</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>如果需要构建大型项目或对模块化支持有较高要求，那么<span class="title class_">Webpack</span>是比较好的选择</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>而如果是在开发模式下需要快速迭代，并且对性能有要求，那么<span class="title class_">Vite</span>则是一个很好的选择</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="12-状态管理存储-localstorage"><a href="#12-状态管理存储-localstorage" class="headerlink" title="12.状态管理存储 , localstorage"></a>12.状态管理存储 , localstorage</h1><h1 id="不熟-13-H5新特新-Web-Worker、WebSocket"><a href="#不熟-13-H5新特新-Web-Worker、WebSocket" class="headerlink" title="@不熟 13.H5新特新:Web Worker、WebSocket"></a>@不熟 13.H5新特新:Web Worker、WebSocket</h1><ul>
<li>Web Worker</li>
<li>WebSocket</li>
</ul>
<h1 id="14-Vue-生命周期的理解"><a href="#14-Vue-生命周期的理解" class="headerlink" title="14.Vue 生命周期的理解"></a>14.Vue 生命周期的理解</h1><h3 id="vue2"><a href="#vue2" class="headerlink" title="vue2"></a>vue2</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> <span class="title function_">beforeCreate</span>()</span><br><span class="line">实例完全被创建之前，会执行这个函数</span><br><span class="line"><span class="title function_">beforeCreate</span>()执行时，data和methods中的数据还没有被初始化</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> <span class="title function_">created</span>() </span><br><span class="line">在created中，data和methods都已经被初始化好了</span><br><span class="line">如果要调用methods中的方法，或者操作data中的数据，最早只能在created中操作</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span> <span class="title function_">beforeMount</span>()</span><br><span class="line">模板已经在内存中编译完成，但是尚未把模板渲染到页面中</span><br><span class="line"></span><br><span class="line"><span class="number">4.</span> <span class="title function_">mounted</span>()</span><br><span class="line">内存中的模板已经真实的挂载到页面中，用户已经可以看到渲染好的页面</span><br><span class="line"></span><br><span class="line"><span class="number">5.</span> <span class="title function_">beforeUpdate</span>()</span><br><span class="line">当执行beforeUpdate的时候，页面中的显示的数据还是旧的，但data数据是最新的，页面尚未和最新的数据保持同步</span><br><span class="line"></span><br><span class="line"><span class="number">6.</span> <span class="title function_">updated</span>()</span><br><span class="line">updated事件执行的时候，页面和data数据已经保持同步了，都是最新的</span><br><span class="line"></span><br><span class="line"><span class="number">7.</span> <span class="title function_">beforeDestroy</span>() </span><br><span class="line">实例销毁前调用vm.$destroy()时触发，实例被销毁的前夕</span><br><span class="line"></span><br><span class="line"><span class="number">8.</span> <span class="title function_">destroyed</span>()</span><br><span class="line">实例销毁完毕，该钩子被调用后，对应<span class="title class_">Vue</span>实例的所有指令都被解绑，所有的事件监听器被移除，所有的子实例也都被销毁。（以后页面就无法动态更新数据了。也就是说无法数据驱动视图。）</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>vue2常用的生命钩子</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> <span class="title function_">mounted</span>(执行一些初始化操作):发送ajax请求、启动定时器、绑定自定义事件、订阅消息</span><br><span class="line"><span class="number">2.</span> <span class="title function_">beforeDestroy</span>(执行一些收尾工作)：清除定时器、解绑自定义事件、取消订阅消息</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>关于销毁vue实例</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 销毁后借助<span class="title class_">Vue</span>开发者工具看不到任何信息。</span><br><span class="line"><span class="number">2.</span> 销毁后自定义事件会失效，但原生<span class="variable constant_">DOM</span>事件依然有效。</span><br><span class="line"><span class="number">3.</span> 一般不会在beforeDestroy操作数据，因为即便操作数据，也不会再触发更新流程了。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="vue3选项式"><a href="#vue3选项式" class="headerlink" title="vue3选项式"></a>vue3选项式</h3><ul>
<li>vue3选项API，生命周期钩子是被暴露Vue实例上的选项，只需要调用这个方法并为这个生命周期钩子编写代码。</li>
<li>vue3选项式API生命周期与vue2大致相同，beforeDestroy()、destroyed()改为beforeUnmount()、unmounted(),实际上作用和用法是一样的</li>
</ul>
<h3 id="vue3组合式"><a href="#vue3组合式" class="headerlink" title="vue3组合式"></a>vue3组合式</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> steup 创建实例前</span><br><span class="line"><span class="number">2.</span> onBeforeMount 挂载<span class="variable constant_">DOM</span>前</span><br><span class="line"><span class="number">3.</span> onMounted 挂载<span class="variable constant_">DOM</span>后</span><br><span class="line"><span class="number">4.</span> onBeforeUpdate 更新组件前</span><br><span class="line"><span class="number">5.</span> onUpdate 更新组件后</span><br><span class="line"><span class="number">6.</span> onBeforeUnmount 卸载销毁前</span><br><span class="line"><span class="number">7.</span> onUnmounted 卸载销毁后 </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>总结</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 与vue2、vue选项式想比，去掉了两个生命周期<span class="title function_">API</span>(beforeCreate、created)，添加了setup</span><br><span class="line"><span class="number">2.</span> 方法名发生变化，名称前多了on，中间使用驼峰式命名</span><br><span class="line"><span class="number">3.</span> 卸载组件的生命周期变化：onBeforeUnmount 、onUnmounted</span><br><span class="line"><span class="number">4.</span> 同一个生命周期可以触发多次</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="15-谈一谈对-MVVM-的理解？"><a href="#15-谈一谈对-MVVM-的理解？" class="headerlink" title="15.谈一谈对 MVVM 的理解？"></a>15.谈一谈对 MVVM 的理解？</h1><ul>
<li>MVVM是 Model-View-ViewModel 的缩写</li>
</ul>
<blockquote>
<p>Model：数据模型<br>View：ui组件<br>ViewModel：一个同步View 和 Model的对象，连接Model和View</p>
</blockquote>
<ul>
<li>在MVVM架构下，viewmodel通过双向数据绑定把model与view连接起来，model与view没有直接联系，</li>
<li>model与view之间的交是相互的，因此view数据的变化会同步到model中，model数据的变化也会立即反应到view上</li>
<li>model和view之间的同步工作是完全自动的，无需人为操作</li>
</ul>
<h1 id="16-Vue-实现双向数据绑定的原理？"><a href="#16-Vue-实现双向数据绑定的原理？" class="headerlink" title="16.Vue 实现双向数据绑定的原理？"></a>16.Vue 实现双向数据绑定的原理？</h1><h3 id="vue2-1"><a href="#vue2-1" class="headerlink" title="vue2"></a>vue2</h3><ul>
<li>在组件创建时，vue会对对组件的data中的每个属性进行代理</li>
<li>当组件中任何一个属性发生变化时，vue会通过Object.defineProperty()方法重新定义该属性的setter方法，从而在属性被重新赋值时触发对应的wather更新对应的DOM节点</li>
</ul>
<h3 id="vue3"><a href="#vue3" class="headerlink" title="vue3"></a>vue3</h3><ul>
<li>Vue3的双向数据绑定底层使用了Proxy API来进行代理。</li>
<li>在组件创建时，Vue3会对组件的data中的每个属性进行代理，使用了Proxy中的handler中的set方法，当组件中的任何一个属性发生变化时，就会触发set方法，从而更新对应的DOM节点。</li>
</ul>
<h1 id="17-Vue2-x-中如何检测数组的变化？"><a href="#17-Vue2-x-中如何检测数组的变化？" class="headerlink" title="17.Vue2.x 中如何检测数组的变化？"></a>17.Vue2.x 中如何检测数组的变化？</h1><ul>
<li>通过vue重写后的7个数组方法(push，pop，shift，unshift，sort，splice，reverse)检测数组的变化</li>
<li>vue将data中的数组，进行了原型链重写。通过原型链指向了重新定义后的数组方法，当调用数组api时，可以通知依赖更新。如果数组中包含引用类型，会对数组内的引用类型再次监控</li>
</ul>
<h1 id="不熟-18-vue2-x-和-vuex3-x-渲染器的-diff-算法分别说一下？"><a href="#不熟-18-vue2-x-和-vuex3-x-渲染器的-diff-算法分别说一下？" class="headerlink" title="不熟@ 18.vue2.x 和 vuex3.x 渲染器的 diff 算法分别说一下？"></a>不熟@ 18.vue2.x 和 vuex3.x 渲染器的 diff 算法分别说一下？</h1><h3 id="vue2-2"><a href="#vue2-2" class="headerlink" title="vue2"></a>vue2</h3><h3 id="vue3-1"><a href="#vue3-1" class="headerlink" title="vue3"></a>vue3</h3><h1 id="19-Vue-的路由实现"><a href="#19-Vue-的路由实现" class="headerlink" title="19.Vue 的路由实现"></a>19.Vue 的路由实现</h1><ul>
<li>路由的原理： 通过改变URL，在不重新请求页面的情况下，更新页面视图</li>
<li>有两种：HashHistory路由、history路由</li>
</ul>
<h3 id="HashHistory路由"><a href="#HashHistory路由" class="headerlink" title="HashHistory路由"></a>HashHistory路由</h3><ul>
<li>vue默认使用hash路由</li>
<li>hash(‘#’)的作用是加载url中指示的网页的位置</li>
<li>HashHistory路由的特点</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 路由地址会有#</span><br><span class="line"><span class="number">2.</span> <span class="string">`#`</span>后面的内容不会传给服务器，也就是说不会重新刷新页面，路由切换也不会重新加载页面</span><br><span class="line"><span class="number">3.</span> 每次改变<span class="title function_">hash</span>(<span class="variable language_">window</span>.<span class="property">localtion</span>.<span class="property">hash</span>),都会在浏览器增加一个历史记录</span><br><span class="line">  举例：</span><br><span class="line">  <span class="attr">http</span>:<span class="comment">//localhost:8080/#/a </span></span><br><span class="line">  <span class="comment">//变为 如下地址，浏览器访问历史中会增加一个记录</span></span><br><span class="line">  <span class="attr">http</span>:<span class="comment">//localhost:8080/#/b </span></span><br><span class="line"><span class="number">4.</span> 可以为hash的改变添加监听事件<span class="string">`window.addEventListener(&quot;hashchange&quot;,funcRef,false)`</span>　　</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>HashHistory路由的两个方法</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> hashHistory.<span class="title function_">push</span>() 将路由添加到浏览器访问历史的栈顶,之前的路由还存在，可以返回之前路由</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> hashHistory.<span class="title function_">replice</span>()  将路由替换掉当前路由，当前路由会成为最新路由,之前的路由会被覆盖，无法返回之前路由</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="history路由"><a href="#history路由" class="headerlink" title="history路由"></a>history路由</h3><ul>
<li><code>HIstory interface</code>是浏览器历史记录栈提供的接口，通过back()、forward()、go()等方法，可以读取浏览器历史记录栈的信息，进行各种跳转操作</li>
<li>history路由原理</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">利用History interface在H5中新增方法pushState()、replaceState(),对浏览器历史记录栈进行修改</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>特点</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> history路由模式，实现单页面的url中没有#,当用户改变路由时，会向服务器发送请求</span><br><span class="line"><span class="number">2.</span> 为了避免这种情况，所以history路由实现方式需要服务器的支持，需要把所有的路由都定向到根页面</span><br><span class="line"><span class="number">3.</span> 在<span class="title class_">HTML5</span> <span class="title class_">History</span> 的构造函数中监听使用<span class="title function_">popState</span>(<span class="variable language_">window</span>.<span class="property">onpopstate</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>history路由的两个方法</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// stateObject:当浏览器跳转到新的状态时，将触发Popstate事件，该事件将携带这个stateObject参数的副本</span></span><br><span class="line"><span class="comment">// title:所添加记录的标题</span></span><br><span class="line"><span class="comment">// url:所添加记录的url</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 和hashHistory.push()功能相似，将路由添加到浏览器访问历史的栈顶,之前的路由还存在，可以返回之前路由</span></span><br><span class="line"><span class="variable language_">window</span>.<span class="property">history</span>.<span class="title function_">pushState</span>(stateObject,title,url) </span><br><span class="line"></span><br><span class="line"><span class="comment">//和hashHistory.replace()功能相似，将路由替换掉当前路由，当前路由会成为最新路由,之前的路由会被覆盖，无法返回之前路由</span></span><br><span class="line"><span class="variable language_">window</span>.<span class="property">history</span>,<span class="title function_">replaceState</span>(stateObject,title,url)  </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="两种路由模式的区别"><a href="#两种路由模式的区别" class="headerlink" title="两种路由模式的区别"></a>两种路由模式的区别</h3><ol>
<li>history模式设置的新的URL可以是与当前URL同源的任意URL<br>hash模式只可修改#后边的部分，故只可设置与当前文档同文档的URL</li>
<li>history模式通过stateObject可以添加任意类型的数据到记录中<br>hash模式只可添加短字符串</li>
<li>history模式可额外设置title属性后供后续使用<br>hash模式没有该功能</li>
<li>history模式会将URL修改得就和正常请求后端的URL一样，如后端没有配置对应的路由处理，则会返回404错误<br>hash模式只改变#后面的内容，跳转路由不刷新页面，故不会向后端发送请求</li>
</ol>
<h3 id="两种路由模式跳转API的区别"><a href="#两种路由模式跳转API的区别" class="headerlink" title="两种路由模式跳转API的区别"></a>两种路由模式跳转API的区别</h3><p>API</p>
<p>hash模式</p>
<p>history模式</p>
<p>push</p>
<p>hashHistory.push()</p>
<p>window.history.pushState()</p>
<p>replice</p>
<p>hashHistory.replice()</p>
<p>window.history,replaceState()</p>
<p>go</p>
<p>window.history.go</p>
<p>window.history.go</p>
<p>back</p>
<p>window.history.go(-1)</p>
<p>window.history.go(-1)</p>
<p>forward</p>
<p>window.history.go(1)</p>
<p>window.history.go(1)</p>
<h1 id="20-vuex和pina的区别"><a href="#20-vuex和pina的区别" class="headerlink" title="20.vuex和pina的区别?"></a>20.vuex和pina的区别?</h1><h3 id="vuex"><a href="#vuex" class="headerlink" title="vuex"></a>vuex</h3><ul>
<li>核心属性：</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> <span class="attr">state</span>:单一状态树，用来存储所有的共享数据</span><br><span class="line">   <span class="comment">//调用方法：</span></span><br><span class="line">   <span class="variable language_">this</span>.<span class="property">$store</span>.<span class="property">state</span>.全局数据名称</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> <span class="attr">getters</span>:状态获取，相当于<span class="string">`state`</span>的计算属性,具有返回值的方法</span><br><span class="line">   <span class="comment">//调用方法：</span></span><br><span class="line">   <span class="variable language_">this</span>.<span class="property">$store</span>.<span class="property">getters</span>.方法名</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span> <span class="attr">mutation</span>:触发同步事件，用于修改state中存储的数据</span><br><span class="line">   <span class="comment">//建议通过mutation操作state中的数据，虽然操作复杂，但可以集中监控state里所有数据的变化</span></span><br><span class="line">   <span class="comment">//直接操作state，state里的数据是无法监控的</span></span><br><span class="line">   <span class="comment">//Mutation中不可以执行异步操作，如需异步，在Action中处理</span></span><br><span class="line">   <span class="comment">//调用方法：</span></span><br><span class="line">   <span class="variable language_">this</span>.<span class="property">$store</span>.<span class="title function_">commit</span>(<span class="string">&#x27;方法名&#x27;</span>,值)</span><br><span class="line"></span><br><span class="line"><span class="number">4.</span> <span class="attr">actions</span>:触发异步事件，用于处理异步任务的，比如网络请求等</span><br><span class="line">   <span class="comment">//调用方法：</span></span><br><span class="line">   <span class="variable language_">this</span>.<span class="property">$store</span>.<span class="title function_">dispatch</span>(<span class="string">&#x27;方法名&#x27;</span>,值)</span><br><span class="line"></span><br><span class="line"><span class="number">5.</span> <span class="attr">module</span>:将vuex进行模块拆分</span><br><span class="line">   <span class="comment">//模块化vuex，可以让每一个模块拥有自己的state、mutation、action、getters,使得结构非常清晰，方便管理</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>总结</li>
</ul>
<ol>
<li>修改state状态必须通过mutations</li>
<li>mutations只能执行同步代码，类似ajax、定时器之类的代码不能在mutations中执行</li>
<li>执行异步代码，要通过actions，然后将数据提交给mutations才可以完成</li>
<li>state的状态即共享数据可以在组件中引用</li>
<li>组件中可以调用action</li>
</ol>
<h3 id="pinia"><a href="#pinia" class="headerlink" title="pinia"></a>pinia</h3><ul>
<li>核心属性</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> state：用来储存全局的数据</span><br><span class="line">   <span class="comment">//访问state：</span></span><br><span class="line">   <span class="keyword">const</span> store=<span class="title function_">useStore</span>()</span><br><span class="line">   store.变量名</span><br><span class="line">   <span class="comment">//重置state：</span></span><br><span class="line">   <span class="keyword">const</span> store=<span class="title function_">useStore</span>()</span><br><span class="line">   store.$reset()</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> getter：监视计算状态的变化，有缓存功能</span><br><span class="line">   <span class="comment">//Getter 等同于 store 的 state 的计算值</span></span><br><span class="line">   <span class="comment">//调用方法</span></span><br><span class="line">   <span class="keyword">const</span> store = <span class="title function_">useStore</span>()</span><br><span class="line">   store.方法名</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span> action：修改state内的全局状态数据</span><br><span class="line">   <span class="comment">//调用方法</span></span><br><span class="line">   <span class="keyword">const</span> store = <span class="title function_">useStore</span>()</span><br><span class="line">   store.方法名</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="vuex与pinia的区别"><a href="#vuex与pinia的区别" class="headerlink" title="vuex与pinia的区别"></a>vuex与pinia的区别</h3><ul>
<li>Vuex和Pinia都是Vue.js的状态管理库</li>
<li>区别</li>
</ul>
<blockquote>
<ol>
<li>vuex是vue.js官方提供的状态管理库<code>&lt;br&gt;</code><br>pinia是基于vue3且使用TS编写的轻量级状态管理库</li>
<li>vuex提供了更完整、更复杂的接口和功能集，如模块、插件等<code>&lt;br&gt;</code><br>pinia只提供了片段式组装store等核心需求</li>
<li>vuex相对稳定，文档和社区支持完善<code>&lt;br&gt;</code><br>pinia侧重于TS风格的开发方式，未来可能会提供更好的维护性和易读性</li>
</ol>
</blockquote>
<h1 id="21-nextTick-的作用是什么？他的实现原理是什么？"><a href="#21-nextTick-的作用是什么？他的实现原理是什么？" class="headerlink" title="21.nextTick 的作用是什么？他的实现原理是什么？"></a>21.<code>nextTick</code> 的作用是什么？他的实现原理是什么？</h1><ul>
<li>vue中DOM更新是异步的</li>
<li>vue实现响应式不是数据发生变化后，DOM立即变化，而是按一定的策略进行DOM更新的</li>
<li>作用</li>
</ul>
<blockquote>
<p>用于下次DOM更新循环结束后执行回调，在修改数据之后使用 <code>nextTick</code>，则可以在回调中获取更新后的DOM</p>
</blockquote>
<ul>
<li>应用场景</li>
</ul>
<blockquote>
<ol>
<li>在Vue生命周期的created()钩子函数进行的DOM操作一定要放在Vue.nextTick()的回调函数中<code>&lt;br&gt;</code><br>原因:在created()钩子函数执行的时候DOM 其实并未进行任何渲染，而此时进行DOM操作无异于徒劳，所以此处一定要将DOM操作的 js 代码放进Vue.nextTick()的回调函数中。与之对应的就是mounted()钩子函数，因为该钩子函数执行时所有的DOM挂载和渲染都已完成，此时在该钩子函数中进行任何DOM操作都不会有问题</li>
<li>在数据变化后要执行的某个操作，而这个操作需要使用随数据改变而改变的DOM结构的时候，这个操作都应该放进Vue.nextTick()的回调函数中。<code>&lt;br&gt;</code></li>
<li>需要在视图更新后，基于新的视图进行操作</li>
</ol>
</blockquote>
<ul>
<li>实现原理</li>
</ul>
<blockquote>
<p><code>nextTick</code>主要是使用了宏任务、微任务，定义了一个异步方法，多次调用 <code>nextTick</code>会将方法存入队列中，通过这个异步方法情况队列</p>
</blockquote>
<h1 id="22-热更新"><a href="#22-热更新" class="headerlink" title="22.热更新"></a>22.热更新</h1><ul>
<li>当代码发生变化时，页面会根据更新后的代码发生变化，无需重新加载页面</li>
</ul>
<h1 id="23-服务端渲染-SSR"><a href="#23-服务端渲染-SSR" class="headerlink" title="23.服务端渲染(SSR)"></a>23.服务端渲染(SSR)</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> <span class="variable constant_">SSR</span>（server side render）服务端渲染</span><br><span class="line"><span class="number">2.</span> <span class="variable constant_">CSR</span>（client side render）客户端渲染</span><br><span class="line"><span class="number">3.</span> <span class="variable constant_">SPA</span>（single page application）单页面应用</span><br><span class="line"><span class="number">4.</span> <span class="variable constant_">SEO</span>（search engine optimization）搜索引擎优化</span><br><span class="line"><span class="number">5.</span> <span class="variable constant_">SSG</span>（<span class="keyword">static</span> side generate）预渲染</span><br><span class="line"><span class="number">6.</span> <span class="variable constant_">AJAX</span>（<span class="title class_">Asynchronous</span> <span class="title class_">Javascript</span> <span class="title class_">And</span> <span class="variable constant_">XML</span>）在不重新加载整个网页的情况下，对网页的局部数据进行更新</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="什么是服务端渲染"><a href="#什么是服务端渲染" class="headerlink" title="什么是服务端渲染"></a>什么是服务端渲染</h3><blockquote>
<p>服务器端完成页面的DOM结果拼接，然后发送到浏览器，为其绑定状态和事件，成为完全可交互的过程</p>
</blockquote>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><blockquote>
<ol>
<li>前端耗时少，因为后端拼接完html，前端只需直接渲染出来</li>
<li>有利于SEO，因为在后端有完整的html页面，有利于爬虫爬取信息，更利于SEO</li>
<li>降低占用客户端资源，因为解析模板的工作完全交给后端，客户端只需解析标准的html页面即可，对客户端的资源占用更少，尤其是移动端，更省电</li>
<li>后端生成静态化文件，可以降低数据查询浪费的时间，对于数据变化不大的页面非常高效</li>
</ol>
</blockquote>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><blockquote>
<ol>
<li>不利于前后端分离，开发效率低</li>
<li>占用服务器端资源</li>
</ol>
</blockquote>
<h3 id="服务器端渲染的方式"><a href="#服务器端渲染的方式" class="headerlink" title="服务器端渲染的方式"></a>服务器端渲染的方式</h3><blockquote>
<ol>
<li>JSP（JavaServer Pages）</li>
<li>express + ejs</li>
<li>express + react</li>
<li>vue + nuxt</li>
</ol>
</blockquote>
<h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><ul>
<li>适用于客户端渲染的项目</li>
</ul>
<blockquote>
<ol>
<li>企业内部项目，管理平台这类不需要SEO的项目，使用客户端渲染能能够提高开发效率，减少服务器资源占用；</li>
<li>强交互项目：对于交互比较多，数据不是很固定的项目，使用客户端渲染，能够让用户更临近于原生APP体验；</li>
</ol>
</blockquote>
<ul>
<li>适用于服务端渲染的项目</li>
</ul>
<blockquote>
<ol>
<li>官网、博客网站、营销类网站：这些网站对SEO和首屏渲染速度更加注重，所以服务端渲染会是较好的选择；</li>
</ol>
</blockquote>
<h1 id="24-react-hooks"><a href="#24-react-hooks" class="headerlink" title="24.react-hooks"></a>24.react-hooks</h1><ul>
<li>什么是hooks</li>
</ul>
<blockquote>
<p>hooks意思是钩子，react hooks就是一堆钩子函数</p>
</blockquote>
<ul>
<li>作用</li>
</ul>
<blockquote>
<p>对函数型进行增强，让函数组件可以存储状态，可以用有处理副作用的能力，让开发可以在不使用类组件的i情况下，实现相同功能</p>
</blockquote>
<ul>
<li>副作用</li>
</ul>
<blockquote>
<ol>
<li>代码中只要不是把数据转换成视图的代码他就属于副作用</li>
<li>副作用代码：发送ajax请求，获取dom，添加点击事件</li>
<li>在类型组件中，一般使用生命周期函数去处理副作用，而在这些函数型组件中，我们就要使用hooks去处理这些函数</li>
</ol>
</blockquote>
<ul>
<li>常见的react hooks</li>
</ul>
<h3 id="1-useState"><a href="#1-useState" class="headerlink" title="1. useState()"></a>1. useState()</h3><blockquote>
<ul>
<li>作用：用于函数组件引入状态</li>
<li>useState()方法内部是使用闭包保存状态数据的</li>
<li>使用细节</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 接收唯一的参数即状态初始值。初始值可以是任意数据类型</span><br><span class="line"><span class="number">2.</span> 返回值为数组。数组中存储状态值和更改状态值的方法。方法名称约定以set开头。后面加上状态名称 </span><br><span class="line"><span class="number">3.</span> 方法可以被多次调用，用以保存不同的状态值</span><br><span class="line"><span class="number">4.</span> 参数可以是一个函数，函数返回什么，初始值就是什么，函数只会被调用一次，用在初始值是动态值的情况</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="2-useReducer"><a href="#2-useReducer" class="headerlink" title="2. useReducer()"></a>2. useReducer()</h3><blockquote>
<ul>
<li>作用：让函数组件保存状态</li>
</ul>
<blockquote>
<ul>
<li>使用方式和rudux的reducer相似,状态都被保存在一个特殊的地方</li>
<li>使用细节</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">第一个参数就是reducer函数，我们创建reducer函数去进行对数据的处理，</span><br><span class="line">第二个参数为状态的初始值</span><br><span class="line"></span><br><span class="line">函数的返回值返回一个数组，数组里面有两个值一个是存储的状态，第二个是触发action的dispatch方法</span><br><span class="line"></span><br><span class="line">自己创建的reducer函数接受两个值，一个是存储的状态另外一个就是触发的action</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</blockquote>
</blockquote>
<h3 id="3-useContext"><a href="#3-useContext" class="headerlink" title="3. useContext()"></a>3. useContext()</h3><blockquote>
<ul>
<li>作用：在跨组件层级获取数据时简化代码</li>
</ul>
</blockquote>
<h3 id="4-useEffect"><a href="#4-useEffect" class="headerlink" title="4. useEffect()"></a>4. useEffect()</h3><blockquote>
<ul>
<li>作用：让函数型组件拥有处理副作用的能力。类似生命周期函数</li>
</ul>
</blockquote>
<h3 id="5-useMemo"><a href="#5-useMemo" class="headerlink" title="5. useMemo()"></a>5. useMemo()</h3><blockquote>
<ul>
<li>作用：类似Vue中的计算属性，可以检测某个值得变化，根据变化值计算新值</li>
<li>useMemo会缓存计算结果。如果检测值没有发生变化，即使组件重新渲染，也不会重新计算</li>
<li>有助于避免在每个渲染上进行昂贵的计算</li>
</ul>
</blockquote>
<h3 id="6-useCallBack"><a href="#6-useCallBack" class="headerlink" title="6. useCallBack()"></a>6. useCallBack()</h3><blockquote>
<ul>
<li>作用：性能优化，缓存函数，使组件重新渲染时得到相同的函数实例</li>
<li>使用场景：</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">当子组件通知父组件的时候，子组件内部状态没有发生改变但是还是进行了重新渲染，memo虽然解决</span><br><span class="line">子组件内部状态没有变阻止子组件重新渲染问题，但是当父组件状态改变，组件发生了重新渲染，</span><br><span class="line">新渲染过后每一次生成的改变状态的函数的实例都变了，导致传递给子组件的方法中的实例变了，</span><br><span class="line">传入的函数实例改变，子组件就会认为组件内部的状态发生了改变，他就会导致重新渲染。解决这</span><br><span class="line">问题的方法就是让传给子组件的函数实例都是同一个这里就要用到<span class="title function_">useCallBack</span>()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="7-useRef"><a href="#7-useRef" class="headerlink" title="7. useRef()"></a>7. useRef()</h3><blockquote>
<ul>
<li>作用：获取dom元素对象,保存数据（跨组件周期）</li>
</ul>
</blockquote>
<h3 id="8-自定义hooks"><a href="#8-自定义hooks" class="headerlink" title="8. 自定义hooks"></a>8. 自定义hooks</h3><blockquote>
<ul>
<li>自定义hook是标准的封装和共享逻辑的方式</li>
<li>自定义hook是一个函数，其名称以use开头</li>
<li>自定义hook其实就是逻辑和内置Hook的组合</li>
</ul>
</blockquote>
<h3 id="9-React路由Hooks"><a href="#9-React路由Hooks" class="headerlink" title="9. React路由Hooks"></a>9. React路由Hooks</h3><ul>
<li>包含了四个钩子函数</li>
</ul>
<blockquote>
<p>useHistory()<br>useLocation()<br>useRouteMatch()<br>useParams()</p>
</blockquote>
<ul>
<li>作用：获取相关的路由信息</li>
</ul>
<h1 id="25-redux"><a href="#25-redux" class="headerlink" title="25.redux"></a>25.redux</h1><ol>
<li>相当于vue中的vuex</li>
<li>redux 是一个独立专门用于做状态管理的 JS 库(不是 react 插件库)</li>
<li>它可以用在 react, angular, vue 等项目中, 但基本与 react 配合使用</li>
<li>作用: 集中式管理 react 应用中多个组件共享的状态</li>
<li>核心概念</li>
</ol>
<blockquote>
<ul>
<li>Store</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 在 redux 里面，只有一个<span class="title class_">Store</span>，整个应用需要管理的数据都在这个<span class="title class_">Store</span>里面。</span><br><span class="line"><span class="number">2.</span> 不能直接改变<span class="title class_">Store</span>的数据，只能通过返回一个新的<span class="title class_">Store</span>去更改它。</span><br><span class="line"><span class="number">3.</span> redux提供了一个<span class="title function_">createStore</span>()方法来创建state</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>action</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">视图层发起的一个操作,通过action改变store内的数据</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>Reducer</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">作用：调用action里的方法</span><br><span class="line">在redux里面，store.<span class="title function_">dispatch</span>()是 <span class="title class_">View</span>发出 <span class="title class_">Action</span> 的唯一方法</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="26-call、apply、bind的作用和区别"><a href="#26-call、apply、bind的作用和区别" class="headerlink" title="26.call、apply、bind的作用和区别"></a>26.call、apply、bind的作用和区别</h1><h3 id="共同点"><a href="#共同点" class="headerlink" title="共同点"></a>共同点</h3><ul>
<li>都可以改变函数内部的this指向</li>
</ul>
<h3 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a>不同点</h3><ol>
<li>call和apply会调用函数，并且改变函数内部this指向。</li>
<li>call和apply传递的参数不一样，call传递参数arg1,arg2…形式apply必须数组形式[arg]</li>
<li>bind不回调用函数，可以改变函数内部this指向。</li>
</ol>
<h3 id="call-方法"><a href="#call-方法" class="headerlink" title="call()方法"></a>call()方法</h3><ol>
<li>改变函数内部this指向,同时调用该函数</li>
<li>语法：</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fun.<span class="title function_">call</span>(thisArg,arg1,arg2,...)</span><br><span class="line"><span class="comment">//thisArg为想要指向的对象，arg1,arg2为参数</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>应用场景：实现继承</li>
</ol>
<h3 id="apply-方法"><a href="#apply-方法" class="headerlink" title="apply()方法"></a>apply()方法</h3><ol>
<li>改变函数内部this指向,同时调用该函数</li>
<li>语法</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">un.<span class="title function_">apply</span>(thisArg,[argsArray])</span><br><span class="line"><span class="comment">//thisArg:在fun函数允许时指定的this值</span></span><br><span class="line"><span class="comment">//argsArray:传递的值，参数必须放在数组里面</span></span><br><span class="line"><span class="comment">//返回值就是函数的返回值</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>应用场景：求数组中最大值</li>
</ol>
<h3 id="bind-方法"><a href="#bind-方法" class="headerlink" title="bind()方法"></a>bind()方法</h3><ol>
<li>改变函数内部this指向,不会调用该函数</li>
<li>语法</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fun.<span class="title function_">bind</span>(thisArg,arg1,arg2,...)</span><br><span class="line"><span class="comment">//thisArg:在fun函数运行时指定的this值</span></span><br><span class="line"><span class="comment">//arg1,arg2:传递的其他参数</span></span><br><span class="line"><span class="comment">//返回由指定的this值和初始化参数改造的原函数拷贝</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>应用场景：有的函数我们不需要立即调用，但是又需要改变这个函数的this指向，此时用bind再合适不过了</li>
</ol>
<h1 id="27-this指向"><a href="#27-this指向" class="headerlink" title="27.this指向"></a>27.this指向</h1><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><blockquote>
<p>在js中，this是一个指针型变量，它动态指向当前函数的运行环境<br>在不同的场景中调用同一个函数，this的指向也可能会发生变化，<br>永远指向其所在函数的真实调用者；如果没有调用者，就指向全局对象window</p>
</blockquote>
<h3 id="this的指向"><a href="#this的指向" class="headerlink" title="this的指向"></a>this的指向</h3><ol>
<li>普通函数：</li>
</ol>
<ul>
<li>严格模式下，必须要写调用该函数的对象，有则this指向该对象，无则undefined</li>
<li>非严格模式下，this指向调用该函数的对象</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">//在严格模式下，对代码的的调用必须严格的写出被调用的函数的对象，不可以有省略或者说简写。</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="string">&quot;use strict&quot;</span>  <span class="comment">//使用严格模式</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">fn</span>()；  <span class="comment">//输出undefined</span></span><br><span class="line">  <span class="variable language_">window</span>.<span class="title function_">fn</span>()； <span class="comment">//输出window</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//非严格模式下，通过test()和window.test()调用函数对象，this都指向window。</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">fn</span>()；  <span class="comment">//输出window</span></span><br><span class="line">  <span class="variable language_">window</span>.<span class="title function_">fn</span>()； <span class="comment">//输出window</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>箭头函数：箭头函数的this指向于函数作用域所用的对象</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 创建箭头函数时，就已经确定了它的 <span class="variable language_">this</span> 指向。</span><br><span class="line"><span class="number">2.</span> 箭头函数内的 <span class="variable language_">this</span> 指向外层的 <span class="variable language_">this</span>。所以要知道箭头函数的 <span class="variable language_">this</span> 就得先知道外层 <span class="variable language_">this</span> 的指向</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>在全局作用域下，this始终指向全局对象window，无论是否是严格模式</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//全局作用域下的this指向</span></span><br><span class="line"><span class="comment">//console.log()完整的写法是window.console.log(),window可以省略</span></span><br><span class="line"><span class="comment">//window调用了console.log()方法，所以此时this指向window</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>) <span class="comment">//输出window</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="4">
<li>对象中的函数：</li>
</ol>
<ul>
<li>普通函数：this指向对象</li>
<li>箭头函数：this指向window</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj=&#123;</span><br><span class="line">  <span class="attr">a</span>:<span class="function">()=&gt;</span><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>),</span><br><span class="line">  <span class="title function_">fn</span>(<span class="params"></span>)&#123;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>)&#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.<span class="title function_">a</span>()  <span class="comment">//输出window</span></span><br><span class="line">obj.<span class="title function_">fn</span>() <span class="comment">//输出&#123;a: ƒ, fn: ƒ&#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="5">
<li>构造函数</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 当使用 <span class="keyword">new</span> 关键字调用构造函数时，函数中的 <span class="variable language_">this</span> 指向实例新对象</span><br><span class="line"><span class="number">2.</span> 直接调用，<span class="variable language_">this</span>指向调用者</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="6">
<li>事件绑定中的this</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 行内绑定,<span class="variable language_">this</span>指向<span class="variable language_">window</span></span><br><span class="line"><span class="number">2.</span> 动态绑定与事件监听,<span class="variable language_">this</span>指向节点对象</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="7">
<li>改变this指向的方法:call()、apply()、bind()</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//call()方法，改变this同时调用函数</span></span><br><span class="line">函数名称.<span class="title function_">call</span>(obj,arg1,arg2…argN);</span><br><span class="line"></span><br><span class="line"><span class="comment">//apply()方法，参数二是一个数组，改变this同时调用函数</span></span><br><span class="line">函数名称.<span class="title function_">apply</span>(obj,[arg1,arg2…,argN]);</span><br><span class="line"></span><br><span class="line"><span class="comment">//bind()方法，和call类似，改变this，但不会调用函数</span></span><br><span class="line">函数名称..<span class="title function_">bind</span>(obj);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="28-垃圾回收机制"><a href="#28-垃圾回收机制" class="headerlink" title="28.垃圾回收机制"></a>28.垃圾回收机制</h1><ul>
<li>什么是垃圾</li>
</ul>
<blockquote>
<ol>
<li>没有引用的对象或变量</li>
<li>无法访问到的对象(多个对象相互引用成环)</li>
</ol>
</blockquote>
<ul>
<li>垃圾回收机制</li>
</ul>
<blockquote>
<p>间歇的不定期的寻找那些不再使用的对象或变量，并释放掉他们占用的内存<br>目的：防止内存泄漏，减小浏览器内存压力</p>
</blockquote>
<ul>
<li>检测垃圾的方式：标记清除法、引用计数法</li>
</ul>
<h3 id="标记清除法"><a href="#标记清除法" class="headerlink" title="标记清除法"></a>标记清除法</h3><p>当函数执行开始，给函数内的变量打上“进入环境”的标记，当函数执行结束后，不再被引用的变量标记为“离开环境”,将这些标记为“离开环境”的变量删除</p>
<h1 id="29-EventLoop-事件循环"><a href="#29-EventLoop-事件循环" class="headerlink" title="29.EventLoop(事件循环)"></a>29.EventLoop(事件循环)</h1><blockquote>
<ol>
<li>同步任务 &gt; nextTick &gt; 其他微任务 &gt; 宏任务</li>
<li>宏任务：I&#x2F;O、定时器、事件绑定、ajax</li>
<li>微任务：Promise的then、catch、finally和process的nextTick</li>
<li>Promise的then等方法是微任务，而Promise中的代码是同步任务</li>
</ol>
</blockquote>
<h1 id="30-内存溢出和内存泄漏"><a href="#30-内存溢出和内存泄漏" class="headerlink" title="30.内存溢出和内存泄漏"></a>30.内存溢出和内存泄漏</h1><h3 id="内存泄露"><a href="#内存泄露" class="headerlink" title="内存泄露"></a>内存泄露</h3><blockquote>
<ul>
<li>用动态储存分配函数内存空间，在使用完毕后未释放，导致一直占据该内存单元,直到程序结束。</li>
<li>常见的内存泄漏：闭包、计时器、回调、事件监听</li>
<li>无用的变量占据了有用的内存</li>
</ul>
</blockquote>
<h3 id="内存溢出"><a href="#内存溢出" class="headerlink" title="内存溢出"></a>内存溢出</h3><blockquote>
<ul>
<li>不顾堆栈分配的局部数据块大小,向数据块中写入过多数据，导致数据越界,结果覆盖了别的数据。常在递归中发生。</li>
<li>内存溢出一般是内存泄漏造成的，会造成浏览器内存不足，崩溃掉</li>
</ul>
</blockquote>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://mochica.top">Mochicar</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://mochica.top/post/8fe9c4e1">http://mochica.top/post/8fe9c4e1</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://mochica.top" target="_blank">Mochicar の 博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="/img/boy.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/butterfly-extsrc/1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdnjs.cloudflare.com/ajax/libs/butterfly-extsrc/1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/post/bd390c75" title="文件流和切片传输"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">文件流和切片传输</div></div></a></div><div class="next-post pull-right"><a href="/post/b2004f8f" title="hexo博客部署github"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">hexo博客部署github</div></div></a></div></nav><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/boy.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Mochicar</div><div class="author-info__description">everything is possible</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">12</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="mailto:m13027235587@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E7%AB%A0%E7%9B%AE%E5%BD%95"><span class="toc-number">1.</span> <span class="toc-text">文章目录</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#1-%E5%87%BD%E6%95%B0%E6%9F%AF%E9%87%8C%E5%8C%96"><span class="toc-number"></span> <span class="toc-text">1. 函数柯里化</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-get%E5%92%8Cpost%E7%9A%84%E5%B7%AE%E5%88%AB"><span class="toc-number"></span> <span class="toc-text">2. get和post的差别</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%8D%E7%86%9F-3-request-payload-%E5%92%8C-form-data%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number"></span> <span class="toc-text">@不熟 3. request payload 和 form data之间的区别</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-HTTP%E3%80%81HTTPs%E5%8D%8F%E8%AE%AE%E8%AF%A6%E7%BB%86%E4%BB%8B%E7%BB%8D"><span class="toc-number"></span> <span class="toc-text">4. HTTP、HTTPs协议详细介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-HTTP%E5%8D%8F%E8%AE%AE%E8%AF%A6%E7%BB%86%E4%BF%A1%E6%81%AF"><span class="toc-number">1.</span> <span class="toc-text">1. HTTP协议详细信息</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-HTTP%E5%8D%8F%E8%AE%AE%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-number">2.</span> <span class="toc-text">2. HTTP协议的特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-HTTP%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="toc-number">3.</span> <span class="toc-text">3. HTTP工作流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-HTTP%E5%8D%8F%E8%AE%AE%E8%AF%B7%E6%B1%82%E6%96%B9%E5%BC%8F-%E5%85%B18%E7%A7%8D"><span class="toc-number">4.</span> <span class="toc-text">4. HTTP协议请求方式(共8种)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-HTTP%E5%8D%8F%E8%AE%AE%E7%8A%B6%E6%80%81%E7%A0%81"><span class="toc-number">5.</span> <span class="toc-text">5.HTTP协议状态码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-HTTPS"><span class="toc-number">6.</span> <span class="toc-text">6.HTTPS</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-v8%E5%BC%95%E6%93%8E%E7%9A%84AST%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number"></span> <span class="toc-text">5.v8引擎的AST是什么</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#6-BFC"><span class="toc-number"></span> <span class="toc-text">6.BFC</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#7-%E6%96%87%E6%A1%A3%E6%B5%81"><span class="toc-number"></span> <span class="toc-text">7.文档流</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E6%A1%A3%E6%B5%81-%E6%A0%87%E5%87%86%E6%B5%81%E3%80%81%E6%99%AE%E9%80%9A%E6%B5%81"><span class="toc-number">1.</span> <span class="toc-text">文档流(标准流、普通流)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%AE%E5%8A%A8%E6%B5%81"><span class="toc-number">2.</span> <span class="toc-text">浮动流</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E4%BD%8D%E6%B5%81"><span class="toc-number">3.</span> <span class="toc-text">定位流</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#8-%E5%B8%83%E5%B1%80%E6%96%B9%E6%A1%88"><span class="toc-number"></span> <span class="toc-text">8.布局方案</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#9-%E6%B5%8F%E8%A7%88%E5%99%A8%E4%BB%8E%E5%8F%91%E5%87%BA%E8%AF%B7%E6%B1%82%E5%88%B0%E6%8E%A5%E5%8F%97%E5%93%8D%E5%BA%94-%E4%B8%AD%E9%97%B4%E8%BF%87%E7%A8%8B"><span class="toc-number"></span> <span class="toc-text">9.浏览器从发出请求到接受响应,中间过程</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#10-%E5%89%8D%E7%AB%AF%E5%AD%98%E5%82%A8"><span class="toc-number"></span> <span class="toc-text">10.前端存储</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E5%8A%BF"><span class="toc-number">1.</span> <span class="toc-text">优势</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F"><span class="toc-number">2.</span> <span class="toc-text">存储方式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E7%B1%BB"><span class="toc-number">2.1.</span> <span class="toc-text">存储类</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%E3%80%812-Web-Storage-localStorage%E3%80%81sessionStorage"><span class="toc-number">2.1.1.</span> <span class="toc-text">1、2. Web Storage(localStorage、sessionStorage)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-cookie"><span class="toc-number">2.1.2.</span> <span class="toc-text">3.cookie</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-IndexDB"><span class="toc-number">2.1.3.</span> <span class="toc-text">4. IndexDB</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-Web-SQL"><span class="toc-number">2.1.4.</span> <span class="toc-text">5. Web SQL</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E7%B1%BB"><span class="toc-number">2.2.</span> <span class="toc-text">缓存类</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-Cache-Storage"><span class="toc-number">2.2.1.</span> <span class="toc-text">1. Cache Storage</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-Application-Cache"><span class="toc-number">2.2.2.</span> <span class="toc-text">2. Application Cache</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#11-vite%E5%92%8Cwebpack%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number"></span> <span class="toc-text">11.vite和webpack的区别</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#12-%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86%E5%AD%98%E5%82%A8-localstorage"><span class="toc-number"></span> <span class="toc-text">12.状态管理存储 , localstorage</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%8D%E7%86%9F-13-H5%E6%96%B0%E7%89%B9%E6%96%B0-Web-Worker%E3%80%81WebSocket"><span class="toc-number"></span> <span class="toc-text">@不熟 13.H5新特新:Web Worker、WebSocket</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#14-Vue-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number"></span> <span class="toc-text">14.Vue 生命周期的理解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#vue2"><span class="toc-number">1.</span> <span class="toc-text">vue2</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#vue3%E9%80%89%E9%A1%B9%E5%BC%8F"><span class="toc-number">2.</span> <span class="toc-text">vue3选项式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#vue3%E7%BB%84%E5%90%88%E5%BC%8F"><span class="toc-number">3.</span> <span class="toc-text">vue3组合式</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#15-%E8%B0%88%E4%B8%80%E8%B0%88%E5%AF%B9-MVVM-%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%9F"><span class="toc-number"></span> <span class="toc-text">15.谈一谈对 MVVM 的理解？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#16-Vue-%E5%AE%9E%E7%8E%B0%E5%8F%8C%E5%90%91%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A%E7%9A%84%E5%8E%9F%E7%90%86%EF%BC%9F"><span class="toc-number"></span> <span class="toc-text">16.Vue 实现双向数据绑定的原理？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#vue2-1"><span class="toc-number">1.</span> <span class="toc-text">vue2</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#vue3"><span class="toc-number">2.</span> <span class="toc-text">vue3</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#17-Vue2-x-%E4%B8%AD%E5%A6%82%E4%BD%95%E6%A3%80%E6%B5%8B%E6%95%B0%E7%BB%84%E7%9A%84%E5%8F%98%E5%8C%96%EF%BC%9F"><span class="toc-number"></span> <span class="toc-text">17.Vue2.x 中如何检测数组的变化？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%8D%E7%86%9F-18-vue2-x-%E5%92%8C-vuex3-x-%E6%B8%B2%E6%9F%93%E5%99%A8%E7%9A%84-diff-%E7%AE%97%E6%B3%95%E5%88%86%E5%88%AB%E8%AF%B4%E4%B8%80%E4%B8%8B%EF%BC%9F"><span class="toc-number"></span> <span class="toc-text">不熟@ 18.vue2.x 和 vuex3.x 渲染器的 diff 算法分别说一下？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#vue2-2"><span class="toc-number">1.</span> <span class="toc-text">vue2</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#vue3-1"><span class="toc-number">2.</span> <span class="toc-text">vue3</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#19-Vue-%E7%9A%84%E8%B7%AF%E7%94%B1%E5%AE%9E%E7%8E%B0"><span class="toc-number"></span> <span class="toc-text">19.Vue 的路由实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#HashHistory%E8%B7%AF%E7%94%B1"><span class="toc-number">1.</span> <span class="toc-text">HashHistory路由</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#history%E8%B7%AF%E7%94%B1"><span class="toc-number">2.</span> <span class="toc-text">history路由</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%A4%E7%A7%8D%E8%B7%AF%E7%94%B1%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">3.</span> <span class="toc-text">两种路由模式的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%A4%E7%A7%8D%E8%B7%AF%E7%94%B1%E6%A8%A1%E5%BC%8F%E8%B7%B3%E8%BD%ACAPI%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">4.</span> <span class="toc-text">两种路由模式跳转API的区别</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#20-vuex%E5%92%8Cpina%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number"></span> <span class="toc-text">20.vuex和pina的区别?</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#vuex"><span class="toc-number">1.</span> <span class="toc-text">vuex</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#pinia"><span class="toc-number">2.</span> <span class="toc-text">pinia</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#vuex%E4%B8%8Epinia%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">3.</span> <span class="toc-text">vuex与pinia的区别</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#21-nextTick-%E7%9A%84%E4%BD%9C%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E4%BB%96%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number"></span> <span class="toc-text">21.nextTick 的作用是什么？他的实现原理是什么？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#22-%E7%83%AD%E6%9B%B4%E6%96%B0"><span class="toc-number"></span> <span class="toc-text">22.热更新</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#23-%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%B8%B2%E6%9F%93-SSR"><span class="toc-number"></span> <span class="toc-text">23.服务端渲染(SSR)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%B8%B2%E6%9F%93"><span class="toc-number">1.</span> <span class="toc-text">什么是服务端渲染</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E7%82%B9"><span class="toc-number">2.</span> <span class="toc-text">优点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%BA%E7%82%B9"><span class="toc-number">3.</span> <span class="toc-text">缺点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E6%B8%B2%E6%9F%93%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="toc-number">4.</span> <span class="toc-text">服务器端渲染的方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">5.</span> <span class="toc-text">应用场景</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#24-react-hooks"><span class="toc-number"></span> <span class="toc-text">24.react-hooks</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-useState"><span class="toc-number">1.</span> <span class="toc-text">1. useState()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-useReducer"><span class="toc-number">2.</span> <span class="toc-text">2. useReducer()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-useContext"><span class="toc-number">3.</span> <span class="toc-text">3. useContext()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-useEffect"><span class="toc-number">4.</span> <span class="toc-text">4. useEffect()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-useMemo"><span class="toc-number">5.</span> <span class="toc-text">5. useMemo()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-useCallBack"><span class="toc-number">6.</span> <span class="toc-text">6. useCallBack()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-useRef"><span class="toc-number">7.</span> <span class="toc-text">7. useRef()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-%E8%87%AA%E5%AE%9A%E4%B9%89hooks"><span class="toc-number">8.</span> <span class="toc-text">8. 自定义hooks</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-React%E8%B7%AF%E7%94%B1Hooks"><span class="toc-number">9.</span> <span class="toc-text">9. React路由Hooks</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#25-redux"><span class="toc-number"></span> <span class="toc-text">25.redux</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#26-call%E3%80%81apply%E3%80%81bind%E7%9A%84%E4%BD%9C%E7%94%A8%E5%92%8C%E5%8C%BA%E5%88%AB"><span class="toc-number"></span> <span class="toc-text">26.call、apply、bind的作用和区别</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B1%E5%90%8C%E7%82%B9"><span class="toc-number">1.</span> <span class="toc-text">共同点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8D%E5%90%8C%E7%82%B9"><span class="toc-number">2.</span> <span class="toc-text">不同点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#call-%E6%96%B9%E6%B3%95"><span class="toc-number">3.</span> <span class="toc-text">call()方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#apply-%E6%96%B9%E6%B3%95"><span class="toc-number">4.</span> <span class="toc-text">apply()方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#bind-%E6%96%B9%E6%B3%95"><span class="toc-number">5.</span> <span class="toc-text">bind()方法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#27-this%E6%8C%87%E5%90%91"><span class="toc-number"></span> <span class="toc-text">27.this指向</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5"><span class="toc-number">1.</span> <span class="toc-text">概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#this%E7%9A%84%E6%8C%87%E5%90%91"><span class="toc-number">2.</span> <span class="toc-text">this的指向</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#28-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6"><span class="toc-number"></span> <span class="toc-text">28.垃圾回收机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%87%E8%AE%B0%E6%B8%85%E9%99%A4%E6%B3%95"><span class="toc-number">1.</span> <span class="toc-text">标记清除法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#29-EventLoop-%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF"><span class="toc-number"></span> <span class="toc-text">29.EventLoop(事件循环)</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#30-%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E5%92%8C%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F"><span class="toc-number"></span> <span class="toc-text">30.内存溢出和内存泄漏</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2"><span class="toc-number">1.</span> <span class="toc-text">内存泄露</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA"><span class="toc-number">2.</span> <span class="toc-text">内存溢出</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/post/a6577751" title="ts快速上手">ts快速上手</a><time datetime="2023-08-01T06:05:02.000Z" title="发表于 2023-08-01 14:05:02">2023-08-01</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/post/692db637" title="fetch和ajax的区别">fetch和ajax的区别</a><time datetime="2023-08-01T06:03:26.000Z" title="发表于 2023-08-01 14:03:26">2023-08-01</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/post/de8f3828" title="console的常见方法">console的常见方法</a><time datetime="2023-08-01T06:02:54.000Z" title="发表于 2023-08-01 14:02:54">2023-08-01</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/post/d3aa27e1" title="小程序canvas2d实现电子签名">小程序canvas2d实现电子签名</a><time datetime="2023-08-01T06:02:15.000Z" title="发表于 2023-08-01 14:02:15">2023-08-01</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/post/e7e9df67" title="使用vite构建项目">使用vite构建项目</a><time datetime="2023-08-01T06:01:32.000Z" title="发表于 2023-08-01 14:01:32">2023-08-01</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div id="ft"><div class="ft-item-1"><div class="t-top"><div class="t-t-l"><p class="ft-t t-l-t">公益广告</p><div class="bg-ad"><div></div>国家反诈中心是国务院打击治理电信网络新型违法犯罪工作部际联席会议合成作战平台，集资源整合、情报研判、侦查指挥为一体，在打击、防范、治理电信网络诈骗等新型违法犯罪中发挥着重要作用。<div class="btn-xz-box"><a class="btn-xz" target="_blank" rel="noopener" href="https://www.hack-gov.com.cn/posts/21480.html">下载（国家反诈中心）APP</a></div></div></div><div class="t-t-r"><p class="ft-t t-l-t">修仙导航</p><ul class="ft-links"><li><a target="_blank" rel="noopener" href="https://fe32.top/articles/hexo1600/">建站指南</a><a target="_blank" rel="noopener" href="https://fe32.top/nav.html">网址导航</a></li><li><a target="_blank" rel="noopener" href="https://fe32.top/sponsorWall/">来杯咖啡</a><a target="_blank" rel="noopener" href="https://fe32.top/comments/">留点什么</a></li><li><a target="_blank" rel="noopener" href="https://fe32.top/about/">关于博主</a><a target="_blank" rel="noopener" href="https://fe32.top/archives/">文章归档</a></li><li><a target="_blank" rel="noopener" href="https://fe32.top/categories/">文章分类</a><a target="_blank" rel="noopener" href="https://fe32.top/tags/">文章标签</a></li><li><a target="_blank" rel="noopener" href="https://fe32.top/gallery/">我的相册</a><a target="_blank" rel="noopener" href="https://fe32.top/bangumis/">我的追番</a></li><li><a target="_blank" rel="noopener" href="https://fe32.top/specialEffects/">一些特效</a><a target="_blank" rel="noopener" href="https://fe32.top/wallpaper/">一些壁纸</a></li></ul></div></div></div><div class="ft-item-2"><p class="ft-t">推荐友链</p><div class="ft-img-group"><div class="img-group-item"><a target="_blank" rel="noopener" href="https://fe32.top/"><img src="https://bu.dusays.com/2022/05/02/626f92e193879.jpg" alt=""/></a></div><div class="img-group-item"><a target="_blank" rel="noopener" href="https://fe32.top/"><img src="https://bu.dusays.com/2022/05/02/626f92e193879.jpg" alt=""/></a></div><div class="img-group-item"><a target="_blank" rel="noopener" href="https://fe32.top/"><img src="https://bu.dusays.com/2022/05/02/626f92e193879.jpg" alt=""/></a></div><div class="img-group-item"><a target="_blank" rel="noopener" href="https://fe32.top/"><img src="https://bu.dusays.com/2022/05/02/626f92e193879.jpg" alt=""/></a></div></div></div></div><div class="copyright">&copy;2023  <i id="heartbeat" class="fa fas fa-heartbeat"></i> Mochicar</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="chat-btn" type="button" title="聊天"><i class="fas fa-sms"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div id="rightMenu"><div class="rightMenu-group rightMenu-small"><div class="rightMenu-item" id="menu-backward"><i class="fa-solid fa-arrow-left"></i></div><div class="rightMenu-item" id="menu-forward"><i class="fa-solid fa-arrow-right"></i></div><div class="rightMenu-item" id="menu-refresh"><i class="fa-solid fa-arrow-rotate-right"></i></div><div class="rightMenu-item" id="menu-home"><i class="fa-solid fa-house"></i></div></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item menu-link" href="/archives/"><i class="fa-solid fa-archive"></i><span>文章归档</span></a><a class="rightMenu-item menu-link" href="/categories/"><i class="fa-solid fa-folder-open"></i><span>文章分类</span></a><a class="rightMenu-item menu-link" href="/tags/"><i class="fa-solid fa-tags"></i><span>文章标签</span></a></div><div class="rightMenu-group rightMenu-line rightMenuNormal"><a class="rightMenu-item menu-link" id="menu-radompage" href="/random/index.html"><i class="fa-solid fa-shoe-prints"></i><span>随便逛逛</span></a><div class="rightMenu-item" id="menu-translate"><i class="fa-solid fa-earth-asia"></i><span>繁简切换</span></div><div class="rightMenu-item" id="menu-darkmode"><i class="fa-solid fa-moon"></i><span>切换模式</span></div></div></div><div id="rightmenu-mask"></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.19/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>(()=>{
  const init = () => {
    twikoo.init(Object.assign({
      el: '#twikoo-wrap',
      envId: '',
      region: '',
      onCommentLoaded: function () {
        btf.loadLightbox(document.querySelectorAll('#twikoo .tk-content img:not(.tk-owo-emotion)'))
      }
    }, null))
  }

  const getCount = () => {
    const countELement = document.getElementById('twikoo-count')
    if(!countELement) return
    twikoo.getCommentsCount({
      envId: '',
      region: '',
      urls: [window.location.pathname],
      includeReply: false
    }).then(function (res) {
      countELement.textContent = res[0].count
    }).catch(function (err) {
      console.error(err);
    });
  }

  const runFn = () => {
    init()
    GLOBAL_CONFIG_SITE.isPost && getCount()
  }

  const loadTwikoo = () => {
    if (typeof twikoo === 'object') {
      setTimeout(runFn,0)
      return
    } 
    getScript('https://cdnjs.cloudflare.com/ajax/libs/twikoo/1.6.16/twikoo.all.min.js').then(runFn)
  }

  if ('Twikoo' === 'Twikoo' || !true) {
    if (true) btf.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else loadTwikoo()
  } else {
    window.loadOtherComment = () => {
      loadTwikoo()
    }
  }
})()</script></div><script defer src="https://npm.elemecdn.com/jquery@latest/dist/jquery.min.js"></script><script defer data-pjax src="/js/rightMenu.js"></script><script defer data-pjax src="/js/cat.js"></script><script src="//code.tidio.co/dlr51oobzk0ix1b3ckkmfy1jw3mmhgkt.js" async="async"></script><script>(() => {
  const isChatBtn = true
  const isChatHideShow = true

  if (isChatBtn) {
    let isShow = false
    const close = () => {
      window.tidioChatApi.hide()
      isShow = false
    }
    
    const open = () => {
      window.tidioChatApi.open()
      window.tidioChatApi.show()
      isShow = true
    }

    const onTidioChatApiReady = () => {
      window.tidioChatApi.hide()
      window.tidioChatApi.on("close", close)
    }
    if (window.tidioChatApi) {
      window.tidioChatApi.on("ready", onTidioChatApiReady)
    } else {
      document.addEventListener("tidioChat-ready", onTidioChatApiReady)
    }

    window.chatBtnFn = () => {
      if (!window.tidioChatApi) return
      isShow ? close() : open()
    }
  } else if (isChatHideShow) {
    window.chatBtn = {
      hide: () => {
        window.tidioChatApi && window.tidioChatApi.hide()
      },
      show: () => {
        window.tidioChatApi && window.tidioChatApi.show()
      }
    }
  }
})()</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div class="no-result" id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/shizuku.model.json"},"display":{"position":"right","width":150,"height":300,"hOffset":40,"vOffset":-20},"mobile":{"show":false},"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/"});</script></body></html>